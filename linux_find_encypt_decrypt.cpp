#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <limits>
#include <sys/types.h>
#include <dirent.h>
#include <cstring>
#include <sys/stat.h>

class FileHandler {
public:
    static std::string ReadFile(const std::string& filePath);
    static void WriteFile(const std::string& filePath, const std::string& content);
};

class Encryptor {
public:
    Encryptor(char key) : encryptionKey(key) {}

    std::string EncryptDecrypt(const std::string& data);
    void EncryptFiles(const std::vector<std::string>& filePaths);
    void DecryptFiles(const std::vector<std::string>& filePaths);

private:
    char encryptionKey;
};

class DirectoryExplorer {
public:
    DirectoryExplorer(const std::string& extension) : fileExtension(extension) {}
    void Explore(const std::string& directoryPath, std::vector<std::string>& filePaths, int level = 0);

private:
    bool HasFileExtension(const std::string& fileName) const;
    std::string fileExtension;

    void PrintIndentation(int level) const;
};

void ShowMenu();
int GetUserChoice();
void ProcessChoice(int choice, Encryptor& encryptor, const std::vector<std::string>& filePaths);

std::string FileHandler::ReadFile(const std::string& filePath) {
    std::ifstream inputFile(filePath, std::ios::in);
    if (!inputFile) {
        std::cerr << "Error: Cannot open file " << filePath << std::endl;
        return "";
    }
    return std::string((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_iterator<char>());
}

void FileHandler::WriteFile(const std::string& filePath, const std::string& content) {
    std::ofstream outputFile(filePath, std::ios::out | std::ios::trunc);
    if (!outputFile) {
        std::cerr << "Error: Cannot write to file " << filePath << std::endl;
        return;
    }
    outputFile << content;
}

std::string Encryptor::EncryptDecrypt(const std::string& data) {
    std::string result = data;
    for (size_t i = 0; i < data.size(); ++i) {
        result[i] = data[i] ^ encryptionKey;  // just simple XOR each character with key to demo, you can apply your encrypt function here
    }
    return result;
}

void Encryptor::EncryptFiles(const std::vector<std::string>& filePaths) {
    for (const auto& filePath : filePaths) {
        std::string fileContent = FileHandler::ReadFile(filePath);
        if (fileContent.empty()) continue;

        // Encrypt content
        std::string encryptedContent = EncryptDecrypt(fileContent);
        FileHandler::WriteFile(filePath, encryptedContent);

        std::cout << "Encrypted file: " << filePath << std::endl;
    }
}

void Encryptor::DecryptFiles(const std::vector<std::string>& filePaths) {
    for (const auto& filePath : filePaths) {
        std::string fileContent = FileHandler::ReadFile(filePath);
        if (fileContent.empty()) continue;

        // Decrypt content
        std::string decryptedContent = EncryptDecrypt(fileContent);
        FileHandler::WriteFile(filePath, decryptedContent);

        std::cout << "Decrypted file: " << filePath << std::endl;
    }
}

void DirectoryExplorer::Explore(const std::string& directoryPath, std::vector<std::string>& filePaths, int level) {
    DIR *dir;
    struct dirent *entry;
    struct stat info;

    if ((dir = opendir(directoryPath.c_str())) == NULL) {
        std::cerr << "Error: Unable to open directory " << directoryPath << std::endl;
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        std::string fileOrDirName = entry->d_name;

        // Skip "." and ".." directories
        if (fileOrDirName == "." || fileOrDirName == "..")
            continue;

        std::string fullPath = directoryPath + "/" + fileOrDirName;

        // Get file/directory information
        if (stat(fullPath.c_str(), &info) != 0) {
            std::cerr << "Error: Unable to get info for " << fullPath << std::endl;
            continue;
        }

        PrintIndentation(level);

        if (S_ISDIR(info.st_mode)) {
            std::cout << "[Directory] " << fileOrDirName << std::endl;
            Explore(fullPath, filePaths, level + 1);
        } else {
            if (HasFileExtension(fileOrDirName)) {
                filePaths.push_back(fullPath);
                std::cout << "[File] " << fileOrDirName << " (stored)" << std::endl;
            }
        }
    }
    closedir(dir);
}

bool DirectoryExplorer::HasFileExtension(const std::string& fileName) const {
    if (fileExtension.empty()) {
        // If fileExtension is empty (i.e., '*'), match all files
        return true;
    }
    return fileName.length() >= fileExtension.length() &&
           fileName.compare(fileName.length() - fileExtension.length(), fileExtension.length(), fileExtension) == 0;
}


void DirectoryExplorer::PrintIndentation(int level) const {
    for (int i = 0; i < level; ++i) {
        std::cout << "  ";
    }
}

void ShowMenu() {
    std::cout << "Menu:\n";
    std::cout << "1.    Encrypt\n";
    std::cout << "2.    Decrypt\n";
    std::cout << "3.    Exit\n";
    std::cout << "Option: ";
}

int GetUserChoice() {
    int option;
    while (true) {
        if (std::cin >> option) break;
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Invalid input. Please enter a number: ";
    }
    return option;
}

void ProcessChoice(int choice, Encryptor& encryptor, const std::vector<std::string>& filePaths) {
    switch (choice) {
        case 1:
            encryptor.EncryptFiles(filePaths);
            break;
        case 2:
            encryptor.DecryptFiles(filePaths);
            break;
        case 3:
            std::cout << "Exiting...\n";
            exit(0);
        default:
            std::cout << "Invalid option. Please choose again.\n";
            break;
    }
}

int main(int argc, char* argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <path> <file_extension> <key>\n";
        return 1;
    }
    std::string directoryPath = argv[1];           
    std::string fileExtension = argv[2];           
    char encryptionKey = argv[3][0];            

    if (fileExtension == "*") {
        fileExtension = ""; 
    }

    std::vector<std::string> filePaths;
    DirectoryExplorer explorer(fileExtension);
    explorer.Explore(directoryPath, filePaths);

    Encryptor encryptor(encryptionKey);

    while (true) {
        ShowMenu();
        int choice = GetUserChoice();
        ProcessChoice(choice, encryptor, filePaths);
    }

    return 0;
}

